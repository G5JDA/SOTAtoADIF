"""
Copyright (c) 2024 Jack G5JDA (https://g5jda.uk)

This file is part of SOTAtoADIF.

SOTAtoADIF is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

SOTAtoADIF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with SOTAtoADIF.
If not, see <https://www.gnu.org/licenses/>.



adif.py

Handles production of ADIF format including output of files
"""

import warnings
from datetime import datetime, timezone
from modules import adif_enums
from SOTAtoADIF import __version__


def generate_header(callsign, now):
    """
    Generates an ADIF header for a given callsign
    :param now: datetime object in UTC with zeroed microseconds
    :param callsign: station callsign as string
    :return: ADIF header as string (this includes a comment as the first two lines & newline at the end)
    """
    now_adif = now.strftime("%Y%m%d %H%M%S")  # convert to the weird ADIF timestamp format
    now_comment = now.strftime("%Y-%m-%d %H:%M:%S")

    header = "# Generated by SOTAtoADIF v{} at {} UTC for {}.\n".format(__version__, now_comment, callsign)
    header += "# SOTAtoADIF is an open-source program authored by G5JDA and licensed under the GNU GPL v3+ license.\n"
    header += "# See https://github.com/G5JDA/SOTAtoADIF or https://g5jda.uk for more info.\n"
    header += "<adif_ver:5>3.1.4\n"
    header += "<programid:10>SOTAtoADIF\n"
    header += "<programversion:{}>{}\n".format(len(__version__), __version__)
    header += "<created_timestamp:{}>{}\n".format(len(now_adif), now_adif)
    header += "<eoh>\n"

    return header


def generate_qsos(callsign, qso_list):
    """

    :param callsign:
    :param qso_list:
    :return:
    """
    qsos_adi = ''
    # TODO do stuff
    # TODO warn but include if not chaser mode and my locator is missing
    # TODO warn and don't include if mode enum isn't found
    # TODO warn and don't include if band enum isn't found

    return qsos_adi


def write_adi(adi_string, callsign, now):
    """
    Write the ADI string to file
    :param adi_string: ADI formatted string, content for output to file
    :param callsign: Callsign for filename generation
    :param now: Datetime for filename generation
    """
    timestamp = now.strftime("%Y-%m-%d_%H-%M-%S")
    filename = "{}_SOTAtoADIF_{}.adi".format(callsign, timestamp)
    filename = filename.replace('/', '-')

    print("Writing ADIF to: {}".format(filename))  # TODO quiet mode

    with open(filename, 'x') as f:
        f.write(adi_string)


def output_logs(log_dict):
    """
    Write out the logs to ADIF files
    :param log_dict: dict in format output by sota_csv.process_qsos()
    :return: Number of files written
    """
    now = datetime.now(timezone.utc).replace(microsecond=0)  # UTC time now - microseconds are unnecessary
    written_count = 0

    # only operate on non-empty input
    if log_dict:
        # loop over station callsigns (this results in one file output per station callsign in log dict)
        for callsign in log_dict.keys():
            # only output a file for this callsign if there are QSOs present
            if log_dict[callsign]:
                adi_string = generate_header(callsign, now)  # prepare adi string with ADIF header
                adi_string += generate_qsos(callsign, log_dict[callsign])  # add the QSO records
                write_adi(adi_string, callsign, now)  # write the .adi
                written_count += 1
            else:
                message = "\nNot outputting file for {} since no QSOs present in processed dict.".format(callsign)
                message += " No QSOs were successfully prepared for output for this callsign."
                warnings.warn(message)

    return written_count
